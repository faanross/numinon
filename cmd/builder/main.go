// cmd/build/main.go is used to compile a binary that is used to build numinon agent
// this 2-step process is required since we wish to embed YAML config and ensure UUID is statically compiled

package main

import (
	"flag"
	"fmt"
	"log"
	"os"
	"os/exec"
	"path/filepath"
	"strings"
	"text/template"

	"github.com/google/uuid"
	"gopkg.in/yaml.v3"

	agentconfig "numinon_shadow/internal/agent/config"
)

const (
	// Paths relative to the project root
	yamlConfigSourcePath   = "cmd/build/agent_config.yaml"  // Agent's YAML config
	embeddedGoConfigTarget = "cmd/agent/embedded_config.go" // Output path for generated Go config
	agentMainPackagePath   = "./cmd/agent"                  // Path to agent's main package for compilation
	defaultOutputDir       = "./bin"                        // Default output directory for binaries
	defaultBinaryNameBase  = "numinonAgent"
)

// Template for embedded_config.go
const configGoTemplate = `// Code generated by cmd/build/main.go; DO NOT EDIT.
    package main
    
    import (
    	"time"
    	"github.com/faanross/punkin_instigator/pkg/agent/config" 
    )
    
    var embeddedAgentConfig = config.AgentConfig{
    	Protocol:                    config.AgentProtocol("{{.Protocol}}"),
    	ServerIP:                    "{{.ServerIP}}",
    	ServerPort:                  "{{.ServerPort}}",
    	CheckInEndpoint:             "{{.CheckInEndpoint}}",
    	ResultsEndpoint:             "{{.ResultsEndpoint}}",
    	WebSocketPath:               "{{.WebSocketPath}}",
    	BaseSleep:                   time.Duration({{.BaseSleepNanoseconds}}),
    	Jitter:                      {{.Jitter}},
    	ConnectionMode:              "{{.ConnectionMode}}",
    	CheckinMethod:               "{{.CheckinMethod}}",
    	EnablePadding:               {{.EnablePadding}},
    	MinPaddingBytes:             {{.MinPaddingBytes}},
    	MaxPaddingBytes:             {{.MaxPaddingBytes}},
    	RequestTimeout:              time.Duration({{.RequestTimeoutNanoseconds}}),
    	ClientConnectTimeout:        time.Duration({{.ClientConnectTimeoutNanoseconds}}),
    	ClientTLSHandshakeTimeout:   time.Duration({{.ClientTLSHandshakeTimeoutNanoseconds}}),
    	ClientResponseHeaderTimeout: time.Duration({{.ClientResponseHeaderTimeoutNanoseconds}}),
    	ClientIdleConnTimeout:       time.Duration({{.ClientIdleConnTimeoutNanoseconds}}),
    	ClientExpectContinueTimeout: time.Duration({{.ClientExpectContinueTimeoutNanoseconds}}),
    	TLSSkipVerify:               {{.TLSSkipVerify}},
    	AgentID:                     "{{.AgentID}}", // This will be the generated UUID
    	MaxRetries:                  {{.MaxRetries}},
    	RetryInterval:               time.Duration({{.RetryIntervalNanoseconds}}),
    }
    
    // getEmbeddedAgentConfig is called by the agent's main.go to retrieve this configuration.
    func getEmbeddedAgentConfig() config.AgentConfig {
    	return embeddedAgentConfig
    }
    `

// templateData is used to pass data to the Go template.
// It embeds agentconfig.AgentConfig and overrides specific fields like AgentID
// and nanosecond representations for durations.
type templateData struct {
	agentconfig.AgentConfig // Embed AgentConfig to access its fields directly in the template
	AgentID                 string

	// Nanosecond versions for time.Duration fields for easy use in template
	BaseSleepNanoseconds                   int64
	RequestTimeoutNanoseconds              int64
	ClientConnectTimeoutNanoseconds        int64
	ClientTLSHandshakeTimeoutNanoseconds   int64
	ClientResponseHeaderTimeoutNanoseconds int64
	ClientIdleConnTimeoutNanoseconds       int64
	ClientExpectContinueTimeoutNanoseconds int64
	RetryIntervalNanoseconds               int64
}

// generateEmbeddedConfig reads the YAML, generates a UUID, and writes the embedded_config.go file.
func generateEmbeddedConfig() error {
	log.Printf("Build: Reading YAML config from '%s'", yamlConfigSourcePath)
	yamlFile, err := os.ReadFile(yamlConfigSourcePath)
	if err != nil {
		return fmt.Errorf("failed to read YAML config file '%s': %w", yamlConfigSourcePath, err)
	}

	var cfgFromYAML agentconfig.AgentConfig
	err = yaml.Unmarshal(yamlFile, &cfgFromYAML)
	if err != nil {
		return fmt.Errorf("failed to unmarshal YAML from '%s': %w", yamlConfigSourcePath, err)
	}

	generatedAgentID := uuid.New().String()
	log.Printf("Build: Generated AgentID: %s", generatedAgentID)

	dataForTemplate := templateData{
		AgentConfig: cfgFromYAML,      // Pass the parsed YAML config
		AgentID:     generatedAgentID, // Set the newly generated AgentID

	}

	tmpl, err := template.New("config").Parse(configGoTemplate)
	if err != nil {
		return fmt.Errorf("failed to parse Go config template: %w", err)
	}

	// Ensure the target directory for embedded_config.go exists
	outputDir := filepath.Dir(embeddedGoConfigTarget)
	if err := os.MkdirAll(outputDir, 0755); err != nil {
		return fmt.Errorf("failed to create directory '%s' for embedded config: %w", outputDir, err)
	}

	file, err := os.Create(embeddedGoConfigTarget)
	if err != nil {
		return fmt.Errorf("failed to create Go config file '%s': %w", embeddedGoConfigTarget, err)
	}
	defer file.Close()

	if err := tmpl.Execute(file, dataForTemplate); err != nil {
		return fmt.Errorf("failed to execute Go config template into '%s': %w", embeddedGoConfigTarget, err)
	}
	log.Printf("Build: Successfully wrote embedded configuration to '%s'", embeddedGoConfigTarget)

	// Manually tidy generated file up using gofmt
	cmdFmt := exec.Command("gofmt", "-w", embeddedGoConfigTarget)
	if output, errFmt := cmdFmt.CombinedOutput(); errFmt != nil {
		// Log as a warning, non-fatal for the build process itself
		log.Printf("Build Warning: gofmt failed on '%s': %v\nOutput: %s", embeddedGoConfigTarget, errFmt, string(output))
	} else {
		log.Printf("Build: Ran gofmt on '%s'", embeddedGoConfigTarget)
	}

	return nil
}

// buildAgent compiles the agent for the specified target OS and architecture.
func buildAgent(targetOS, targetArch, outputDir, binaryNameBase string) error {
	finalBinaryName := fmt.Sprintf("%s_%s_%s", binaryNameBase, targetOS, targetArch)
	if targetOS == "windows" {
		finalBinaryName += ".exe"
	}
	outputPath := filepath.Join(outputDir, finalBinaryName)

	log.Printf("Build: Compiling agent for %s/%s -> %s", targetOS, targetArch, outputPath)

	cmd := exec.Command("go", "build", "-ldflags=-s -w", "-o", outputPath, agentMainPackagePath)
	cmd.Env = append(os.Environ(), // Inherit current environment
		fmt.Sprintf("GOOS=%s", targetOS),
		fmt.Sprintf("GOARCH=%s", targetArch),
		"CGO_ENABLED=0", // Disable CGO for easier cross-compilation
	)

	buildOutput, err := cmd.CombinedOutput()
	if err != nil {
		return fmt.Errorf("go build failed for %s/%s: %w\nBuild Output:\n%s", targetOS, targetArch, err, string(buildOutput))
	}
	log.Printf("Build: Successfully built agent: %s", outputPath)
	return nil
}

func main() {
	log.Println("Starting Numinon Agent Compiler build process...")

	// Define flags for controlling build targets
	// NOTE: If no flag is provided will determine host OS + ARCH and compile for that automatically
	target := flag.String("target", "current", "Build target: current, windows-amd64, linux-amd64, darwin-amd64, darwin-arm64, all")
	flag.Parse()

	// Step 1: Generate the embedded_config.go file from cmd/build/agent_config.yaml
	if err := generateEmbeddedConfig(); err != nil {
		log.Fatalf("Build Error: Failed to generate embedded config: %v", err)
	}

	// Step 2: Compile the agent based on the target flag
	var buildErrors []string

	buildSpecificTarget := func(os, arch string) {
		if err := buildAgent(os, arch, defaultOutputDir, defaultBinaryNameBase); err != nil {
			errStr := fmt.Sprintf("Error building for %s/%s: %v", os, arch, err)
			log.Println(errStr)
			buildErrors = append(buildErrors, errStr)
		}
	}

	switch *target {
	case "current":
		log.Println("Build target: current host OS/ARCH")
		// Get host OS/Arch
		cmdHost := exec.Command("go", "env", "GOOS")
		goosBytes, _ := cmdHost.Output()
		hostOS := strings.TrimSpace(string(goosBytes))
		if hostOS == "" {
			hostOS = "darwin"
		} // fallback in case OS cannot be determined

		cmdHostArch := exec.Command("go", "env", "GOARCH")
		goarchBytes, _ := cmdHostArch.Output()
		hostArch := strings.TrimSpace(string(goarchBytes))
		if hostArch == "" {
			hostArch = "amd64"
		} // fallback in case ARCH cannot be determined
		buildSpecificTarget(hostOS, hostArch)
	case "windows-amd64":
		buildSpecificTarget("windows", "amd64")
	case "linux-amd64":
		buildSpecificTarget("linux", "amd64")
	case "darwin-amd64":
		buildSpecificTarget("darwin", "amd64")
	case "darwin-arm64":
		buildSpecificTarget("darwin", "arm64")
	case "all":
		log.Println("Build target: all common platforms")
		buildSpecificTarget("windows", "amd64")
		buildSpecificTarget("linux", "amd64")
		buildSpecificTarget("darwin", "amd64")
		buildSpecificTarget("darwin", "arm64")
	default:
		log.Fatalf("Build Error: Unknown target '%s'. Valid targets: current, windows-amd64, linux-amd64, darwin-amd64, darwin-arm64, all", *target)
	}

	if len(buildErrors) > 0 {
		log.Printf("Build process finished with %d error(s):", len(buildErrors))
		for _, e := range buildErrors {
			log.Println(e)
		}
		os.Exit(1)
	} else {
		log.Println("Build process finished successfully.")
	}
}
